/**
 * JavaCC file
 */

options {
    JDK_VERSION = "1.8";
    STATIC = false;
    UNICODE_INPUT = true;
}
PARSER_BEGIN(BooleanFormulaParser)
package org.workcraft.formula.jj;

import java.util.Collection;
import java.util.Map;
import java.util.HashMap;
import java.io.Reader;
import java.io.StringReader;

import org.workcraft.formula.BooleanFormula;
import org.workcraft.formula.BooleanVariable;
import org.workcraft.formula.FreeVariable;
import org.workcraft.formula.workers.BooleanWorker;
import org.workcraft.formula.visitors.StringGenerator;
import org.workcraft.formula.workers.DumbBooleanWorker;
import org.workcraft.types.Func;

public class BooleanFormulaParser {

    private BooleanWorker worker;
    private Func<String, ? extends BooleanFormula> variableResolver;

    public BooleanFormulaParser(Reader reader,
            Func<String, ? extends BooleanFormula> variableResolver,
            BooleanWorker worker) {

        this(reader);
        this.variableResolver = variableResolver;
        this.worker = worker;
    }

    private BooleanFormula var(String name) throws ParseException {
        BooleanFormula result = variableResolver.eval(name);
        if (result == null) {
            throw new ParseException("Undefined variable: '" + name + "'");
        }
        return result;
    }

    public static BooleanFormula parse(String text, Func<String, ? extends BooleanFormula> variableResolver)
            throws ParseException {

        return parse(text, variableResolver, DumbBooleanWorker.getInstance());
    }

    public static BooleanFormula parse(String text, Func<String, ? extends BooleanFormula> variableResolver,
            BooleanWorker worker) throws ParseException {

        if ((text == null) || text.isEmpty()) {
            return null;
        }
        // Add trailing space to prevent uninformative errors referring to <EOF>
        if (!text.endsWith(" ")) {
            text = text + ' ';
        }
        return new BooleanFormulaParser(new StringReader(text), variableResolver, worker).formula();
    }

    public static BooleanFormula parse(String text, Collection<? extends BooleanVariable> variables)
            throws ParseException {

        final Map<String, BooleanVariable> labelToVariableMap = new HashMap<>();
        for(BooleanVariable var : variables) {
            labelToVariableMap.put(var.getLabel(), var);
        }
        // JavaCC v7.0.13 does not support Java 1.8 syntax for lambdas yet
        return parse(text, new Func<String, BooleanVariable>() {
            @Override
            public BooleanVariable eval(String label) {
                return labelToVariableMap.get(label);
            }
        });
    }

    public static BooleanFormula parse(String text) throws ParseException {
        final Map<String, BooleanVariable> labelToVariableMap = new HashMap<>();
        // JavaCC v7.0.13 does not support Java 1.8 syntax for lambdas yet
        return BooleanFormulaParser.parse(text, new Func<String, BooleanVariable>() {
            @Override
            public BooleanVariable eval(String label) {
                if (!labelToVariableMap.containsKey(label)) {
                    labelToVariableMap.put(label, new FreeVariable(label));
                }
                return labelToVariableMap.get(label);
            }
        });
    }

}

PARSER_END(BooleanFormulaParser)

SKIP :
{
    " "
|
    "\r"
|
    "\t"
|
    "\n"
}

TOKEN :
{
    <EQUAL: "=" | "==" | "<->" | "<=>">
|
    <NOT_EQUAL: "!=">
|
    <IMPLY: "=>" | "\u21d2" | "->">
|
    <OR: "|" | "+" | "\u2228">
|
    <XOR: "^" | "\u2295">
|
    <AND: "&" | "*" | "\u2227" | "\u2022" | "\u00b7">
|
    <NOT: "!" | "~" | "\u00ac">
|
    <POSTPIX_NOT: "'">
|
    <OPEN_BRACKET: "(">
|
    <CLOSE_BRACKET: ")">
|
    <CONSTANT0: "0">
|
    <CONSTANT1: "1">
|
    <VARIABLE: ["@", "A"-"Z", "a"-"z", "_"](["A"-"Z", "a"-"z", "_", "0"-"9", ".", "[", "]"])*>
}

BooleanFormula formula() :
{
    BooleanFormula result;
}
{
    result = expression() <EOF>
    { return result; }
}

BooleanFormula expression() :
{
    BooleanFormula result;
    BooleanFormula op;
}
{
    result = eqOp() ( <EQUAL> op = eqOp()
    { result = worker.iff(result, op); } )*
    { return result; }
}

BooleanFormula eqOp() :
{
    BooleanFormula result;
    BooleanFormula op;
}
{
    result = neqOp() ( <NOT_EQUAL> op = neqOp()
    { result = worker.xor(result, op); } ) *
    { return result; }
}

BooleanFormula neqOp() :
{
    BooleanFormula result;
    BooleanFormula op;
}
{
    result = implyOp() [ <IMPLY> op = implyOp()
    { result = worker.imply(result, op); } ]
    { return result; }
}

BooleanFormula implyOp() :
{
    BooleanFormula result;
    BooleanFormula op;
}
{
    result = orOp() ( <OR> op = orOp()
    { result = worker.or(result, op); } ) *
    { return result; }
}

BooleanFormula orOp() :
{
    BooleanFormula result;
    BooleanFormula op;
}
{
    result = xorOp() ( <XOR> op = xorOp()
    { result = worker.xor(result, op); } ) *
    { return result; }
}

BooleanFormula xorOp() :
{
    BooleanFormula result;
    BooleanFormula op;
}
{
    result = andOp() ( <AND> op = andOp()
    { result = worker.and(result, op); } ) *
    { return result; }
}

BooleanFormula andOp() :
{
    boolean inverse = false;
    BooleanFormula result;
}
{
    (<NOT> { inverse = !inverse; } )*
    result = literal()
    (<POSTPIX_NOT> { inverse = !inverse; } )*
    { return inverse ? worker.not(result) : result; }
}

BooleanFormula literal() :
{
    Token t;
    BooleanFormula result;
}
{
    (
        t = <VARIABLE>
        { result = var(t.image); }
    |
        t = <CONSTANT0>
        { result = worker.zero(); }
    |
        t = <CONSTANT1>
        { result = worker.one(); }
    |
        <OPEN_BRACKET> result = expression() <CLOSE_BRACKET>
    )
    { return result; }
}
