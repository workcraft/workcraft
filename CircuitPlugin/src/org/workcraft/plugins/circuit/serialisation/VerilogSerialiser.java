/*
*
* Copyright 2008,2009 Newcastle University
*
* This file is part of Workcraft.
*
* Workcraft is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* Workcraft is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with Workcraft.  If not, see <http://www.gnu.org/licenses/>.
*
*/

package org.workcraft.plugins.circuit.serialisation;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.UUID;

import org.workcraft.Framework;
import org.workcraft.dom.Model;
import org.workcraft.dom.hierarchy.NamespaceHelper;
import org.workcraft.exceptions.ArgumentException;
import org.workcraft.plugins.circuit.Circuit;
import org.workcraft.plugins.circuit.CircuitSettings;
import org.workcraft.plugins.circuit.CircuitUtils;
import org.workcraft.plugins.circuit.Contact;
import org.workcraft.plugins.circuit.FunctionComponent;
import org.workcraft.plugins.circuit.javacc.ParseException;
import org.workcraft.plugins.circuit.javacc.SubstitutionParser;
import org.workcraft.plugins.circuit.verilog.SubstitutionRule;
import org.workcraft.plugins.shared.CommonDebugSettings;
import org.workcraft.serialisation.Format;
import org.workcraft.serialisation.ModelSerialiser;
import org.workcraft.serialisation.ReferenceProducer;
import org.workcraft.util.Func;
import org.workcraft.util.Hierarchy;
import org.workcraft.util.LogUtils;

public class VerilogSerialiser implements ModelSerialiser {

    private static final String KEYWORD_OUTPUT = "output";
    private static final String KEYWORD_INPUT = "input";
    private static final String KEYWORD_MODULE = "module";
    private static final String KEYWORD_ENDMODULE = "endmodule";

    class ReferenceResolver implements ReferenceProducer {
        HashMap<Object, String> refMap = new HashMap<Object, String>();

        @Override
        public String getReference(Object obj) {
            return refMap.get(obj);
        }
    }

    @Override
    public ReferenceProducer serialise(Model model, OutputStream outStream, ReferenceProducer inRef) {
        PrintWriter out = new PrintWriter(outStream);
        out.println("// Verilog netlist file generated by Workcraft -- http://workcraft.org/\n");

        ReferenceResolver resolver = new ReferenceResolver();

        if (model instanceof Circuit) {
            writeCircuit(out, (Circuit)model);
        } else {
            throw new ArgumentException("Model class not supported: " + model.getClass().getName());
        }
        out.close();
        return resolver;
    }

    @Override
    public boolean isApplicableTo(Model model) {
        return model instanceof Circuit;
    }

    @Override
    public String getDescription() {
        return "Workcraft Verilog serialiser";
    }

    @Override
    public String getExtension() {
        return ".v";
    }

    @Override
    public UUID getFormatUUID() {
        return Format.VERILOG;
    }

    private void writeCircuit(PrintWriter out, Circuit circuit) {
        writeHeader(out, circuit);
        writeInstances(out, circuit);
        writeInitialState(out, circuit);
        out.println(KEYWORD_ENDMODULE);
    }

    private void writeHeader(PrintWriter out, Circuit circuit) {
        String topName = circuit.getTitle();
        if ((topName == null) || topName.isEmpty()) {
            LogUtils.logWarningLine("The top module does not have a name.");
            topName = "";
        }
        out.print(KEYWORD_MODULE + " " + topName + " (");
        boolean isFirstPort = true;
        boolean hasPorts = false;
        for (Contact contact: Hierarchy.getDescendantsOfType(circuit.getRoot(), Contact.class, new Func<Contact, Boolean>() {
            @Override
            public Boolean eval(Contact arg) {
                return arg.isPort();
            }
        })) {
            if (isFirstPort) {
                isFirstPort = false;
            } else {
                out.print(",");
                hasPorts = true;
            }
            String contactType = contact.isInput() ? KEYWORD_INPUT : KEYWORD_OUTPUT;
            String contactRef = circuit.getNodeReference(contact);
            String contactFlatName = NamespaceHelper.hierarchicalToFlatName(contactRef);
            out.print("\n    " + contactType + " " + contactFlatName);
        }
        if (hasPorts) {
            out.print("\n");
        }
        out.print(");\n\n");
    }

    private void writeInstances(PrintWriter out, Circuit circuit) {
        HashMap<String, SubstitutionRule> substitutionRules = readSubsritutionRules();
        for (FunctionComponent component: Hierarchy.getDescendantsOfType(circuit.getRoot(), FunctionComponent.class)) {
            String moduleName = component.getModule();
            String instanceRef = circuit.getNodeReference(component);
            String instanceFlatName = NamespaceHelper.hierarchicalToFlatName(instanceRef);
            if ((moduleName == null) || moduleName.isEmpty()) {
                LogUtils.logWarningLine("Component '" + instanceFlatName + "' is not associated to a module.");
                moduleName = "";
            }
            SubstitutionRule substitutionRule = substitutionRules.get(moduleName);
            if (substitutionRule != null) {
                String newModuleName = substitutionRule.newName;
                if (newModuleName != null) {
                    LogUtils.logInfoLine("In component '" + instanceFlatName + "' renaming module '" + moduleName + "' to '" + newModuleName + "'.");
                    moduleName = newModuleName;
                }
            }
            if (component.getIsZeroDelay() && (component.isBuffer() || component.isInverter())) {
                out.println("    // This inverter should have a short delay");
            }
            out.print("    " + moduleName + " " + instanceFlatName + " (");
            boolean first = true;
            for (Contact contact: component.getContacts()) {
                if (first) {
                    first = false;
                } else {
                    out.print(", ");
                }
                String contactName = contact.getName();
                String wireName = CircuitUtils.getWireName(circuit, contact);
                if ((wireName == null) || wireName.isEmpty()) {
                    LogUtils.logWarningLine("In component '" + instanceFlatName + "' contact '" + contactName + "' is disconnected.");
                    wireName = "";
                }
                if (substitutionRule != null) {
                    String newContactName = substitutionRule.substitutions.get(contactName);
                    if (newContactName != null) {
                        LogUtils.logInfoLine("In component '" + instanceFlatName + "' renaming contact '" + contactName + "' to '" + newContactName + "'.");
                        contactName = newContactName;
                    }
                }
                out.print("." + contactName + "(" + wireName + ")");
            }
            out.print(");\n");
        }
    }

    private HashMap<String, SubstitutionRule> readSubsritutionRules() {
        HashMap<String, SubstitutionRule> result = new HashMap<>();
        String substitutionsFileName = CircuitSettings.getSubstitutionLibrary();
        if ((substitutionsFileName == null) || substitutionsFileName.isEmpty()) {
            LogUtils.logWarningLine("File of substitutions is not specified.");
        } else {
            File libraryFile = new File(substitutionsFileName);
            final Framework framework = Framework.getInstance();
            if (framework.checkFile(libraryFile, "Access error for the file of substitutions")) {
                try {
                    InputStream genlibInputStream = new FileInputStream(substitutionsFileName);
                    SubstitutionParser substitutionParser = new SubstitutionParser(genlibInputStream);
                    if (CommonDebugSettings.getParserTracing()) {
                        substitutionParser.enable_tracing();
                    } else {
                        substitutionParser.disable_tracing();
                    }
                    List<SubstitutionRule> rules = substitutionParser.parseSubstitutionRules();
                    for (SubstitutionRule rule: rules) {
                        result.put(rule.oldName, rule);
                    }
                    LogUtils.logInfoLine("Renaming gates and pins using the file of substitutions '" + substitutionsFileName + "'.");
                } catch (FileNotFoundException e) {
                } catch (ParseException e) {
                    LogUtils.logWarningLine("Could not parse the file of substitutions '" + substitutionsFileName + "'.");
                }
            }
        }
        return result;
    }

    private void writeInitialState(PrintWriter out, Circuit circuit) {
        HashSet<Contact> contacts = new HashSet<>();
        for (Contact contact: Hierarchy.getDescendantsOfType(circuit.getRoot(), Contact.class, new Func<Contact, Boolean>() {
            @Override
            public Boolean eval(Contact arg) {
                return arg.isPort() != arg.isOutput();
            }
        })) {
            contacts.add(contact);
        }
        out.println();
        out.println("    // signal values at the initial state:");
        out.print("    //");
        for (Contact contact: contacts) {
            String wireName = CircuitUtils.getWireName(circuit, contact);
            if ((wireName != null) && !wireName.isEmpty()) {
                out.print(" ");
                if (!contact.getInitToOne()) {
                    out.print("!");
                }
                out.print(wireName);
            }
        }
        out.println();
    }

}
