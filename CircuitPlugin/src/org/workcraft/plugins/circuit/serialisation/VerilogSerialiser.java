/*
*
* Copyright 2008,2009 Newcastle University
*
* This file is part of Workcraft.
*
* Workcraft is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* Workcraft is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with Workcraft.  If not, see <http://www.gnu.org/licenses/>.
*
*/

package org.workcraft.plugins.circuit.serialisation;

import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.UUID;

import org.workcraft.dom.Model;
import org.workcraft.dom.hierarchy.NamespaceHelper;
import org.workcraft.exceptions.ArgumentException;
import org.workcraft.plugins.circuit.Circuit;
import org.workcraft.plugins.circuit.CircuitComponent;
import org.workcraft.plugins.circuit.CircuitUtils;
import org.workcraft.plugins.circuit.Contact;
import org.workcraft.serialisation.Format;
import org.workcraft.serialisation.ModelSerialiser;
import org.workcraft.serialisation.ReferenceProducer;
import org.workcraft.util.Func;
import org.workcraft.util.Hierarchy;

public class VerilogSerialiser implements ModelSerialiser {

	private static final String KEYWORD_OUTPUT = "output";
	private static final String KEYWORD_INPUT = "input";
	private static final String KEYWORD_MODULE = "module ";
	private static final String KEYWORD_ENDMODULE = "endmodule";

	class ReferenceResolver implements ReferenceProducer {
		HashMap<Object, String> refMap = new HashMap<Object, String>();

		@Override
		public String getReference(Object obj) {
			return refMap.get(obj);
		}
	}

	@Override
	public ReferenceProducer serialise(Model model, OutputStream outStream, ReferenceProducer inRef) {
		PrintWriter out = new PrintWriter(outStream);
		out.println("// Verilog netlist file generated by Workcraft -- http://workcraft.org/\n");

		ReferenceResolver resolver = new ReferenceResolver();

		if (model instanceof Circuit) {
			writeCircuit(out, (Circuit)model);
		} else {
			throw new ArgumentException ("Model class not supported: " + model.getClass().getName());
		}
		out.close();
		return resolver;
	}

	@Override
	public boolean isApplicableTo(Model model) {
		return (model instanceof Circuit);
	}

	@Override
	public String getDescription() {
		return "Workcraft Verilog serialiser";
	}

	@Override
	public String getExtension() {
		return ".v";
	}

	@Override
	public UUID getFormatUUID() {
		return Format.VERILOG;
	}

	private void writeHeader(PrintWriter out, Circuit circuit) {
		String topName = circuit.getTitle();
		if ((topName == null) || topName.isEmpty()) {
			System.out.println("  Warning: the top module does not have a name.");
			topName = "";
		}
		out.print(KEYWORD_MODULE + " " + topName + " (");
		boolean isFirstPort = true;
		boolean hasPorts = false;
		for (Contact contact: Hierarchy.getDescendantsOfType(circuit.getRoot(), Contact.class, new Func<Contact, Boolean>() {
			@Override
			public Boolean eval(Contact arg) {
				return (arg.isPort());
			}
		})) {
			if (isFirstPort) {
				isFirstPort = false;
			} else {
				out.print(",");
				hasPorts = true;
			}
			String contactType = contact.isInput() ? KEYWORD_INPUT : KEYWORD_OUTPUT;
			String contactRef = circuit.getNodeReference(contact);
			String contactFlatName = NamespaceHelper.hierarchicalToFlatName(contactRef);
			out.print("\n    " + contactType + " " + contactFlatName);
		}
		if (hasPorts) {
			out.print("\n");
		}
		out.print(");\n\n");
	}

	private void writeInstances(PrintWriter out, Circuit circuit) {
		for (CircuitComponent component: Hierarchy.getDescendantsOfType(circuit.getRoot(), CircuitComponent.class)) {
			String moduleName = component.getModule();
			String instanceRef = circuit.getNodeReference(component);
			String instanceFlatName = NamespaceHelper.hierarchicalToFlatName(instanceRef);
			if ((moduleName == null) || moduleName.isEmpty()) {
				System.out.println("  Warning: component '" + instanceFlatName + "' is not associated to a module.");
				moduleName = "";
			}
			out.print("    " + moduleName + " " + instanceFlatName + " (");
			boolean first = true;
			for (Contact contact: component.getContacts()) {
				if (first) {
					first = false;
				} else {
					out.print(", ");
				}
				String contactName = contact.getName();
				String wireName = CircuitUtils.getWireName(circuit, contact);
				if ((wireName == null) || wireName.isEmpty()) {
					System.out.println("  Warning: contact '" + contactName + "' of component '"+ instanceFlatName + "' is disconnected.");
					wireName = "";
				}
				out.print("." + contactName + "(" + wireName + ")");
			}
			out.print(");\n");
		}
	}

	private void writeCircuit(PrintWriter out, Circuit circuit) {
		writeHeader(out, circuit);
		writeInstances(out, circuit);
		out.println(KEYWORD_ENDMODULE);
	}

}
